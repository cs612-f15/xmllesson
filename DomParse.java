// This code is adapted from DomEcho06.java of SUN' J2EE Tutorial
import javax.xml.parsers.DocumentBuilder; 
import javax.xml.parsers.DocumentBuilderFactory;  
import javax.xml.parsers.FactoryConfigurationError;  
import javax.xml.parsers.ParserConfigurationException;
 
import org.xml.sax.SAXException;  
import org.xml.sax.SAXParseException;  
import org.xml.sax.ErrorHandler;

import java.io.*;

import org.w3c.dom.Document;
import org.w3c.dom.DOMException;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

public class DomParse 
{
    // Global value so it can be ref'd by the tree-adapter
    static Document document; 

    // decides whether to compress inline elements like <em> and <b>
    static boolean compress = false; 


    static boolean useSchema = false; // whether the XML doc uses DTD or XML Schema

    public static void main(String argv[])
    {

        if (argv[0].equals("-c"))
        {
          compress = true;
          argv[0] = argv[1];  // replace argv[0] with XML file name
        }
        else
          compress = false;

        DocumentBuilderFactory factory =
            DocumentBuilderFactory.newInstance();
        if (isValidating(argv))
        {
          factory.setValidating(true); 
          System.out.println("Validation is on");
        }  
        else
          System.out.println("Validation is off");
        factory.setNamespaceAware(true);
        if (useSchema)
          factory.setAttribute(
            "http://java.sun.com/xml/jaxp/properties/schemaLanguage",
            "http://www.w3.org/2001/XMLSchema"
          );
        try {
           DocumentBuilder builder = factory.newDocumentBuilder();
           builder.setErrorHandler(new MyErrorHandler());
           document = builder.parse( new File(argv[0]) );

        } catch (SAXParseException spe) {
           // Error generated by the parser
           System.out.println("\n** Parsing error"
              + ", line " + spe.getLineNumber()
              + ", uri " + spe.getSystemId());
           System.out.println("   " + spe.getMessage() );

           // Use the contained exception, if any
           Exception  x = spe;
           if (spe.getException() != null)
               x = spe.getException();
           x.printStackTrace();
 
        } catch (SAXException sxe) {
           // Error generated during parsing)
           Exception  x = sxe;
           if (sxe.getException() != null)
               x = sxe.getException();
           x.printStackTrace();

        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();

        } catch (IOException ioe) {
           // I/O error
           ioe.printStackTrace();
        }
    } // main
    
    // Does the XML file have DTD or Schema file for validation?
    static boolean isValidating(String argv[]) 
    {
    	// check whether the top 10 lines of the XML file have "chemaLocation=" or "<!DOCTYPE"
    	try 
    	{
    		File f = new File(argv[0]);
    		BufferedReader br = new BufferedReader(new FileReader(f));
    		String line = br.readLine();
  			for (int i = 0; (i < 10) && (line != null); i++)
  			{
    			if (line.indexOf("chemaLocation=") != -1) 
    			{
    			  useSchema = true;
    			  return true;
    			}
    			if (line.indexOf("<!DOCTYPE") != -1)
    			{
    			  useSchema = false;
    				return true;
    			}
    			line = br.readLine();
    		}
    	}
    	catch (Exception e){}
    	return false;
    }



    // build a dummy DOM tree to show manual DOM tree manipulation
    public static void buildDom()
    {
        DocumentBuilderFactory factory =
           DocumentBuilderFactory.newInstance();
        try {
          DocumentBuilder builder = factory.newDocumentBuilder();
          document = builder.newDocument();  // Create from scratch

          Element root = 
                  (Element) document.createElement("rootElement"); 
          document.appendChild(root);
          // show off the normalize() function for collapsing text nodes
          root.appendChild( document.createTextNode("<b>Usage: ") );
          root.appendChild( document.createTextNode(" "));
          root.appendChild( document.createTextNode("java DomParse [-c] [XML-file]</b><br>") );
          root.appendChild( document.createTextNode(
            "<br>You use optional \"-c\" if you want to compress inline nodes like &lt;em>."));
          root.appendChild( document.createTextNode(
            "<br>Set up DTD or Schema files in the XML file."));
          // normalize text representation
          // getDocumentElement() returns the document's root node
          document.getDocumentElement().normalize();   
        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();
        }
    } // buildDom



    // An array of names for DOM node-types
    // (Array indexes = nodeType() values.)
    static final String[] typeName = {
        "none",
        "Element",
        "Attr",
        "Text",
        "CDATA",
        "EntityRef",
        "Entity",
        "ProcInstr",
        "Comment",
        "Document",
        "DocType",
        "DocFragment",
        "Notation",
    };
    static final int ELEMENT_TYPE =   Node.ELEMENT_NODE;
    static final int ATTR_TYPE =      Node.ATTRIBUTE_NODE;
    static final int TEXT_TYPE =      Node.TEXT_NODE;
    static final int CDATA_TYPE =     Node.CDATA_SECTION_NODE;
    static final int ENTITYREF_TYPE = Node.ENTITY_REFERENCE_NODE;
    static final int ENTITY_TYPE =    Node.ENTITY_NODE;
    static final int PROCINSTR_TYPE = Node.PROCESSING_INSTRUCTION_NODE;
    static final int COMMENT_TYPE =   Node.COMMENT_NODE;
    static final int DOCUMENT_TYPE =  Node.DOCUMENT_NODE;
    static final int DOCTYPE_TYPE =   Node.DOCUMENT_TYPE_NODE;
    static final int DOCFRAG_TYPE =   Node.DOCUMENT_FRAGMENT_NODE;
    static final int NOTATION_TYPE =  Node.NOTATION_NODE;    

    
    // determines which nodes should be compressed out
    boolean treeElement(String en) {
      if (en.equals("b") || en.equals("B") || en.equals("em") || en.equals("EM") ||
          en.equals("br") || en.equals("BR"))
        return false;
      else
        return true;
    }

    // This class wraps a DOM node and returns the text we want to
    // display in the tree. It also returns children, index values,
    // and child counts.
    public class AdapterNode 
    { 
      org.w3c.dom.Node domNode;

      // Construct an Adapter node from a DOM node
      public AdapterNode(org.w3c.dom.Node node) {
        domNode = node;
      }

      // Return a string that identifies this node in the tree
      public String toString() {
        String s = typeName[domNode.getNodeType()];
        String nodeName = domNode.getNodeName();
        if (! nodeName.startsWith("#")) {
           s += ": " + nodeName;
        }
        if (compress) {
           String t = content().trim();
           int x = t.indexOf("\n");
           if (x >= 0) t = t.substring(0, x);
           s += " " + t;
           return s;
        }
        if (domNode.getNodeValue() != null) {
           if (s.startsWith("ProcInstr")) 
              s += ", "; 
           else 
              s += ": ";
           // Trim the value to get rid of NL's at the front
           String t = domNode.getNodeValue().trim();
           int x = t.indexOf("\n");
           if (x >= 0) t = t.substring(0, x);
           s += t;
        }
        return s;
      }

      public String content() {
        String s = "";
        org.w3c.dom.NodeList nodeList = domNode.getChildNodes();
        for (int i=0; i<nodeList.getLength(); i++) {
          org.w3c.dom.Node node = nodeList.item(i);
          int type = node.getNodeType();
          AdapterNode adpNode = new AdapterNode(node); //inefficient, but works
          if (type == ELEMENT_TYPE) {
            // Skip subelements that are displayed in the tree.   
            if ( treeElement(node.getNodeName()) ) continue;

            // EXTRA-CREDIT HOMEWORK:
            //   Special case the SLIDE element to use the TITLE text
            //   and ignore TITLE element when constructing the tree.

            // EXTRA-CREDIT
            //   Convert ITEM elements to html lists using
            //   <ul>, <li>, </ul> tags

            s += "<" + node.getNodeName() + ">";
            s += adpNode.content();
            s += "</" + node.getNodeName() + ">";
          } else if (type == TEXT_TYPE) {
            s += node.getNodeValue();
          } else if (type == ENTITYREF_TYPE) {
            // The content is in the TEXT node under it
            s += adpNode.content();
          } else if (type == CDATA_TYPE) {
            // The "value" has the text, same as a text node.
            //   while EntityRef has it in a text node underneath.
            //   (because EntityRef can contain multiple subelements)
            // Convert angle brackets and ampersands for display
            StringBuffer sb = new StringBuffer( node.getNodeValue() );
            for (int j=0; j<sb.length(); j++) {
              if (sb.charAt(j) == '<') {
                sb.setCharAt(j, '&');
                sb.insert(j+1, "lt;");
                j += 3;
              } else if (sb.charAt(j) == '&') {
                sb.setCharAt(j, '&');
                sb.insert(j+1, "amp;");
                j += 4;
              }
            }
            s += "<pre>" + sb + "\n</pre>";
          }
           // Ignoring these:
           //   ATTR_TYPE      -- not in the DOM tree
           //   ENTITY_TYPE    -- does not appear in the DOM
           //   PROCINSTR_TYPE -- not "data"
           //   COMMENT_TYPE   -- not "data"
           //   DOCUMENT_TYPE  -- Root node only. No data to display.
           //   DOCTYPE_TYPE   -- Appears under the root only
           //   DOCFRAG_TYPE   -- equiv. to "document" for fragments
           //   NOTATION_TYPE  -- nothing but binary data in here
        }
        return s;
      }

      /*
       * Return children, index, and count values
       */
      public int index(AdapterNode child) {
        //System.err.println("Looking for index of " + child);
        int count = childCount();
        for (int i=0; i<count; i++) {
          AdapterNode n = this.child(i);
          if (child.domNode == n.domNode) return i;
        }
        return -1; // Should never get here.
      }

      public AdapterNode child(int searchIndex) {
        //Note: JTree index is zero-based. 
        org.w3c.dom.Node node = 
             domNode.getChildNodes().item(searchIndex);
        if (compress) {
          // Return Nth displayable node
          int elementNodeIndex = 0;
          for (int i=0; i<domNode.getChildNodes().getLength(); i++) {
            node = domNode.getChildNodes().item(i);
            if (node.getNodeType() == ELEMENT_TYPE 
            && treeElement( node.getNodeName() )
            && elementNodeIndex++ == searchIndex) {
               break; 
            }
          }
        }
        return new AdapterNode(node); 
      }

      public int childCount() {
        if (!compress) {
          // Indent this
          return domNode.getChildNodes().getLength();  
        } 
        int count = 0;
        for (int i=0; i<domNode.getChildNodes().getLength(); i++) {
           org.w3c.dom.Node node = domNode.getChildNodes().item(i); 
           if (node.getNodeType() == ELEMENT_TYPE
           && treeElement( node.getNodeName() )) 
           {
             // Note: 
             //   Have to check for proper type. 
             //   The DOCTYPE element also has the right name
             ++count;
           }
        }
        return count;
      }
    }

}

class MyErrorHandler implements ErrorHandler 
{
 // treat validation errors as fatal
  public void error(SAXParseException e)
  throws SAXParseException
  {
    throw e;
  }

  // dump warnings too
  public void warning(SAXParseException err)
  throws SAXParseException
  {
    System.out.println("** Warning"
          + ", line " + err.getLineNumber()
          + ", uri " + err.getSystemId());
    System.out.println("   " + err.getMessage());
  }

  public void fatalError(SAXParseException e) 
  throws SAXParseException
  {
    throw e;
  }
}
