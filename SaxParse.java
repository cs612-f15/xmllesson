// This code is adapted from Echo12.java of SUN's J2EE Tutorial v1.4
import java.io.*;

import org.xml.sax.*;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.ext.LexicalHandler;

import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;

public class SaxParse extends DefaultHandler
  implements LexicalHandler
{
  StringBuffer textBuffer;
  static boolean validateDTD = false;     // validating parse with DTD
  static boolean validateSchema = false;  // validating parse with Schema
  static boolean internal = false;        // DTD file must be specified in the XML file
                          // internal = true iff DTD or Schema is specified in XML file
  
  static final String JAXP_SCHEMA_LANGUAGE =
        "http://java.sun.com/xml/jaxp/properties/schemaLanguage";
  static final String W3C_XML_SCHEMA =
        "http://www.w3.org/2001/XMLSchema";
  static final String JAXP_SCHEMA_SOURCE =
        "http://java.sun.com/xml/jaxp/properties/schemaSource";
        
  public static void main(String argv[])
  {
    if (argv.length < 1 || argv.length > 2) 
	  {
      System.err.println("Usage: java SaxParse XML-file [Schema-file]");
      System.exit(1);
    }
        
    boolean isValidating = false;
    boolean hasError = false;
    // Use an instance of ourselves as the SAX event handler
    SaxParse handler = new SaxParse();
    SAXParserFactory factory = SAXParserFactory.newInstance();
    if (isValidating = isValidating(argv)) {
      factory.setValidating(true);
      System.out.println("<!------- Validation is on ----------->");
    }
    else
      System.out.println("<!------- Validation is off ----------->");
    System.out.println("<!------------- Output --------------->");

    factory.setNamespaceAware(true);
    try {
      // Set up output stream
      out = new OutputStreamWriter(System.out, "UTF8");

      // Parse the input
      SAXParser saxParser = factory.newSAXParser();
      
      if (validateSchema)
        saxParser.setProperty(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);
 
      if (validateSchema && !internal) // Schema file specified on command line
        saxParser.setProperty(JAXP_SCHEMA_SOURCE,	new File(argv[1]));
      
      XMLReader xmlReader = saxParser.getXMLReader();
      xmlReader.setProperty(
        "http://xml.org/sax/properties/lexical-handler",
         handler
         );        
 
      saxParser.parse(new File(argv[0]), handler);

    } catch (SAXParseException spe) {
      // Error generated by the parser
      hasError = true;
      System.out.println("\n** Parsing error"
        + ", line " + spe.getLineNumber()
        + ", uri " + spe.getSystemId());
      System.out.println("   " + spe.getMessage() );
      
      // Use the contained exception, if any
      Exception  x = spe;
      if (spe.getException() != null)
        x = spe.getException();
      x.printStackTrace();

    } catch (SAXException sxe) {
      // Error generated by this application
      // (or a parser-initialization error)
      hasError = true;
      Exception  x = sxe;
      if (sxe.getException() != null)
        x = sxe.getException();
      x.printStackTrace();

    } catch (ParserConfigurationException pce) {
      // Parser with specified options can't be built
      hasError = true;
      pce.printStackTrace();

    } catch (IOException ioe) {
      // I/O error
      hasError = true;
      ioe.printStackTrace();

    } catch (Throwable t) {
       hasError = true;
       t.printStackTrace();
    }
    if (isValidating) {
      if (!hasError)
        System.out.println("\n---Validation succeeded---");
      else
        System.out.println("\n---Validation failed---");
    }
    System.exit(0);
  }
  
  // Does the XML file have DTD or Schema file for validation?
  static boolean isValidating(String argv[]) 
  {
  	if (argv.length == 2) { // dtd or Schema file is specified
  		if (argv[1].endsWith(".dtd")) 
  		  System.out.println("DTD file cannot be specified on command-line");
  		if (argv[1].endsWith(".xsd")) {
  		  validateSchema = true;
  		  internal = false;
  		  return true;
  		}
    }
    internal = true;  // schema or DTD file may be specified in the XML file
  	// check whether the top 20 lines of the XML file have "chemaLocation=" or "<!DOCTYPE"
  	try 
  	{
  		File f = new File(argv[0]);
  		BufferedReader br = new BufferedReader(new FileReader(f));
  		String line = br.readLine();
			for (int i = 0; (line != null) && (i < 20); i++)
			{
  			if (line.indexOf("chemaLocation=") != -1)
  			  validateSchema = true;
  			if (line.indexOf("<!DOCTYPE") != -1)
  			  validateDTD = true;
  			if (validateSchema || validateDTD)
  				return true;
  			line = br.readLine();
  		}
  	}
  	catch (Exception e){}
  	return false;
  }
    
 
  static private Writer  out;
  private String indentString = "    "; // Amount to indent
  private int indentLevel = -1;

  //===========================================================
  // SAX DocumentHandler methods
  //===========================================================

  public void setDocumentLocator(Locator l)
  {
  }

  public void startDocument()
  throws SAXException
  {
    //emit("START DOCUMENT");
    //nl();
    emit("<?xml version='1.0' encoding='UTF-8'?>");
  }

  public void endDocument()
  throws SAXException
  {
    try {
      nl();
      out.flush();
    } catch (IOException e) {
      throw new SAXException("I/O error", e);
    }
  }

  public void startElement(String namespaceURI,
                           String sName, // simple name
                           String qName, // qualified name
                           Attributes attrs)
  throws SAXException
  {
    echoText();
    String eName = sName; // element name
    if ("".equals(eName)) eName = qName; // not namespaceAware
   	indentLevel++;
    nl(); 
    emit("<"+eName);
    if (attrs != null) {
      for (int i = 0; i < attrs.getLength(); i++) {
        String aName = attrs.getLocalName(i); // Attr name 
        if ("".equals(aName)) aName = attrs.getQName(i);
        nl();
        emit("   ");
        emit(aName);
        emit("=\"");
        emit(attrs.getValue(i));
        emit("\"");
      }
    }
    if (attrs.getLength() > 0) nl();
    emit(">");
  }
  
  public void endElement(String namespaceURI,
                         String sName, // simple name
                         String qName  // qualified name
                        )
  throws SAXException
  {
    String eName = sName; // element name
    if ("".equals(eName)) eName = qName; // not namespaceAware
   	echoText();
    nl();
    emit("</"+eName+">");
    indentLevel--;
  }

  public void characters(char buf[], int offset, int len)
  throws SAXException
  {
    String s = new String(buf, offset, len);
    if (textBuffer == null) {
      textBuffer = new StringBuffer(s);
    } else {
      textBuffer.append(s);
    }
  }
  
  public void ignorableWhitespace(char buf[], int offset, int len)
  throws SAXException
  {
    // Ignore it
  }

  public void processingInstruction(String target, String data)
  throws SAXException
  {
    indentLevel++;
    nl();
    //emit("PROCESS: ");
    emit("<?"+target+" "+data+"?>");
    indentLevel--;
  }

  //===========================================================
  // SAX ErrorHandler methods
  //===========================================================

  // treat validation errors as fatal
  public void error(SAXParseException e)
  throws SAXParseException
  {
    throw e;
  }

  // dump warnings too
  public void warning(SAXParseException err)
  throws SAXParseException
  {
    System.out.println("** Warning"
          + ", line " + err.getLineNumber()
          + ", uri " + err.getSystemId());
    System.out.println("   " + err.getMessage());
  }

  //===========================================================
  // LexicalEventListener methods
  //===========================================================
    
  public void comment(char[] ch, int start, int length)
  throws SAXException
  {
  }

  public void startCDATA()
  throws SAXException
  {
    echoText(); // echo anything we've seen before now
    nl(); 
    //emit("START CDATA SECTION");
  }

  public void endCDATA()
  throws SAXException
  {
    echoText(); // echo the CDATA text
    nl(); 
    //emit("END CDATA SECTION");
  }

  public void startEntity(java.lang.String name)
  throws SAXException
  {
    //echoText(); // echo anything we've seen before now
    //nl(); 
    //emit("START ENTITY: "+name);
  }

  public void endEntity(java.lang.String name)
  throws SAXException
  {
    //echoText(); // echo the ENTITY text
    //nl(); 
    //emit("END ENTITY: "+name);
  }
  
  public void startDTD(String name, String publicId, String systemId)
  throws SAXException
  {
    //nl(); 
    //emit("START DTD: "+name
    //        +"\n           publicId=" + publicId
    //        +"\n           systemId=" + systemId);
  }
  
  public void endDTD()
  throws SAXException
  {
    //nl(); 
    //emit("END DTD");
  }

  //===========================================================
  // Utility Methods ...
  //===========================================================
  
  // Display text accumulated in the character buffer
  private void echoText()
  throws SAXException
  {
    if (textBuffer == null) return;   
   	nl(); 
    emit("    ");
    String s = ""+textBuffer;
    if (!s.trim().equals("")) emit(s);
      textBuffer = null;
  }

  // Wrap I/O exceptions in SAX exceptions, to
  // suit handler signature requirements
  private void emit(String s)
  throws SAXException
  {
    try {
      out.write(s);
      out.flush();
    } catch (IOException e) {
      throw new SAXException("I/O error", e);
    }
  }

  // Start a new line
  // and indent the next line appropriately
  private void nl()
  throws SAXException
  {
    String lineEnd = System.getProperty("line.separator");
    try {
      out.write(lineEnd);
      for (int i=0; i < indentLevel; i++) out.write(indentString);
    } catch (IOException e) {
      throw new SAXException("I/O error", e);
    }
  }
}
